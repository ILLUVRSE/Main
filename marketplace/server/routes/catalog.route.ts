import { Router, Request, Response } from 'express';

const router = Router();

/**
 * GET /catalog
 *
 * Query params:
 *  - page (default 1)
 *  - page_size (default 20)
 *  - query
 *  - tags (comma separated)
 *  - author
 *
 * Response:
 * {
 *   ok: true,
 *   items: [{ sku_id, title, summary, price, currency, manifest_valid }],
 *   page, page_size, total
 * }
 *
 * This handler will attempt to use a DB helper at ../lib/db (if implemented).
 * If not present, it returns an empty list (or a single sample item in DEV to assist manual testing).
 */
router.get('/catalog', async (req: Request, res: Response) => {
  const page = Math.max(1, Number(req.query.page || 1));
  const pageSize = Math.min(100, Math.max(1, Number(req.query.page_size || 20)));
  const query = String(req.query.query || '').trim();
  const tags = String(req.query.tags || '').split(',').map((t) => t.trim()).filter(Boolean);
  const author = String(req.query.author || '').trim();

  // Try to use a DB client if implemented at server/lib/db.ts
  let db: any = null;
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const mod = require('../lib/db');
    db = mod && (mod.default || mod);
  } catch {
    db = null;
  }

  try {
    if (db && typeof db.query === 'function') {
      // Build a very small SQL-based filter. Adapt this when you implement schema.
      const whereClauses: string[] = [];
      const params: any[] = [];

      if (query) {
        params.push(`%${query}%`);
        whereClauses.push(`(title ILIKE $${params.length} OR summary ILIKE $${params.length})`);
      }
      if (author) {
        params.push(author);
        whereClauses.push(`author_id = $${params.length}`);
      }
      if (tags.length > 0) {
        // Assuming a tags text[] or tags relation, adapt as needed. Here we do a simple ILIKE match.
        params.push(`%${tags.join('%')}%`);
        whereClauses.push(`tags::text ILIKE $${params.length}`);
      }

      const whereSql = whereClauses.length ? `WHERE ${whereClauses.join(' AND ')}` : '';
      const offset = (page - 1) * pageSize;

      // NOTE: adapt table/column names when creating migrations/schema
      const itemsSql = `SELECT sku_id, title, coalesce(summary, '') as summary, coalesce(price,0) as price, coalesce(currency,'USD') as currency, coalesce(manifest_valid, false) as manifest_valid
        FROM skus
        ${whereSql}
        ORDER BY title ASC
        LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;

      params.push(pageSize, offset);

      const countSql = `SELECT count(*) as total FROM skus ${whereSql}`;

      const itemsResult = await db.query(itemsSql, params);
      const countResult = await db.query(countSql, params.slice(0, params.length - 2));

      const items = (itemsResult.rows || []).map((r: any) => ({
        sku_id: r.sku_id,
        title: r.title,
        summary: r.summary,
        price: r.price,
        currency: r.currency,
        manifest_valid: Boolean(r.manifest_valid),
      }));

      const total = Number((countResult.rows && countResult.rows[0] && countResult.rows[0].total) || 0);

      return res.json({
        ok: true,
        items,
        page,
        page_size: pageSize,
        total,
      });
    }

    // No DB available â€” return a safe default response.
    // In development, include a helpful sample item to make manual testing easier.
    const sampleItem =
      process.env.NODE_ENV !== 'production'
        ? [
            {
              sku_id: 'sku-abc-123',
              title: 'Sample Model (dev)',
              summary: 'A sample SKU generated by the dev catalog route.',
              price: 19999,
              currency: 'USD',
              manifest_valid: true,
            },
          ]
        : [];

    return res.json({
      ok: true,
      items: sampleItem,
      page,
      page_size: pageSize,
      total: sampleItem.length,
    });
  } catch (err: any) {
    // Unexpected errors map to the standard error envelope
    return res.status(500).json({
      ok: false,
      error: {
        code: err?.code || 'CATALOG_ERROR',
        message: err?.message || 'Failed to fetch catalog',
        details: err?.details,
      },
    });
  }
});

export default router;

